Общие комментарии
=================

Нужны комментарии
-----------------

> > Я думаю тут имеет смысл заменить датапоинты на классы - тогда будет намного 
> > меньше оверхед по памяти, а то их много а ключи каждый раз сохраняются
> 
> Нужен комменатрий: заменить на класс Datapoint() - мне казалось это наоборот 
> ест больше памяти/времени. непонятно как из инстансов Datapoint созадвать 
> датафрейм. еще идея заменить точки просто на кортеж, но тогда немного 
> теряется читаемость. 

Можно заменить на namedtuple - это будет тот же кортеж, но только с доступом как
по полям класса. Оверхеда по памяти по сравнению с кортежами нет, по
производительности не проверял, но едва ли там будет что то значимое.
В любом случае наверняка лучше чем словарь.

Ещё если создавать поверх всего этого датафрейм, то можно попробовать массивы
нампай для структур. Они очень удобные, можно хранить разные типы, обращаться
по полям и так далее. Оверхеда нет, возможно в том числе и по производительности. корее наоборот будет работать очень оптимально по сравнению с обычными структурами,
потому что нампай.

> > Ещё, правда, я бы использовал регекс по другому, в файле фильтров. 
> > Но это скорее потому что я им просто не доверяю, хотя онлайн чекер тоже 
> > выдаёт предупреждение:
> 
> это один из вопросов реакторинга, он уже помечен в файле, желательно что-то 
> поконкретнее сказать про регексы - там два заменяемые функции проверки для года, 
> какую оставить или модифицировать?

Я бы не сказал что они вообще разные, только на уровне одного параметра.
В зависимости от того может ли быть шум из букв, я бы оставил clean year,
возможно только изменить второй символ с 'w' (любой вайтспейс) на 'D'
(любая не цифра).

> > Можно попробовать использовать намбу, это библиотека для оптимизации пайтонокода, 
> > она умеет в jit компиляции и если вызывов чтения csv за запуск программы будет 
> > несколько то она себя окупит
> 
> нужно гонять на 12 * 11 месяцах и чем быстрее тем лучше. сейчас в 
> но с намбой не работал, не знаю как. вопрос: не дает ли какого-нибуд выигрыша 
> треды/процессы? надо ли их пробовать?

От тредов есть польза только если есть блокирующие операции - например веб
запросы, чтение файлов. Процессы работают чуть по другому - у них огромная
проблема что нет общей памяти и они дублируют память процесса питона. Но зато
они хорошо используют новые ядра. Если можно так распараллелить программу,
что она может полностью независимиво обрабатываться в два вызова функции,
то тогда от процессов будет отличная польза. Пример такой параллелизации -
оригинальный процесс запускает две функции, каждая из которых читает свою
половину файла. Потом они вместе выводят датапоинты и оригинальный процесс их куда
то записывает. Возможно в отсортированном виде.

Сама по себе намба может помочь если есть функции которые часто запускаются.
Она сделает джит компиляцию за пол секунды, и потом они будут работать раза
в два быстрее. Она по своей сути напоминает нампай, тоже переводит пайтоновские
обьекты в более оптимальный код

> Генераторы не везде используются правильно, иногда просто как списки. Но это в целом не важно если нет 
> сильного лимита по памяти, а тут вроде не очень огромные файлы

C генераторами было несколько намерений:
- они удобнее читаются, правильнее оертывать импорт csv  
- можно создавать пайпы из них 
- идея была тянуть в виде генераторов до выхода из reader.py, потом что далее мы режем
  одни и те же точки на частоты, и по-видимому нужен список, чтобы генератор не израсходовался
  (создалась годовая частота, а квартальная нет)
- по идее список должен выдавать reader.to_values(), далее работа со спиком.  

Скорее да
----------    

Что-то из предложений выше
    
Нейтрально
----------    
    
>Ещё в некоторых местах можно использовать массивы нампая - например в датаровс, 
>они уменьшать потребление памяти раза в 2-3
часть с датароус мормозит меншье, нужно скорее смотреть как работать с частью saver.py

    
Скорее нет
----------    
> Ещё можно использовать pandas и делать всё в нём. Я правда не очень люблю эту 
> библиотеку - у неё очень неприятный синтаксис, и что то сделать уже огромное количество времени забирает. 
> Но по скорости и по памяти оно должно быть значительно лучше.
pandas меcтами сильно тупит, предлагается из класса Tables выдавать поток точек, 
а потом уже заниматься преобразованиями как сейчас в saver.py

текущие наблюдения:
- pandas.offsets.MonthEnd() дико тормозит, исключено
- [x for x in values if x['freq']] работает медленнее, чем создать датафрейм и сделать df[df.freq==freq]
- посомтреть замеры в dev_helper.py, там есть необъясненный вопрос


> Стилистички и по структуре мне код очень нравится. Там были проблемы в первых версиях, 
> но сейчас всё вполне ок. Есть только типичные предупреждения линтера про названия 
> переменных и комментарии функций

dev_helper.py надо во что-то переименовывать?

Новые вопросы
=============

> Просьба посмотреть на тайминг - запустиь dev_helper.py. Там могут быть проблемы 
> с измерением, но картина такая что reader.py работает быстро достаточно,
> а тормозит часть с созданием pandas. Плюс возможна какая-то этономия времени 
> на том что мы из длинного списка values выбирать значения с удалением, делая его короче

Просмотрел код - там была серьезная ошибка в замерах, потому казалось что пандас
работает значительно хуже. Почти в два раза дольше - потому что значения
считывались дважды.

> что скажете про тесты? они колчаются какие-то перекрещенные между 
> локальными юнит-тестами и интеграционными, есть ли какие-то идеи, что в первую 
> очередь протестировать, что-то поменять?

Тесты выглядят хорошо. Не знаю что ещё можно было бы добавить.

Насчёт тех вопросов которые идут в начале файла тестов - то я думаю имеет смысл вообще все константы вынести в отдельных конфиг файл.

> можно ли как-то вывести coverage для python-minimal? или уже сейчас выводится он
> в www?

Можно, только для этого желательно переписать тесты на фреймворке unittest. 

- [ ] в большой версии есть подход по тестированию значений которые получаются -
тестируются итоговые фреймы с помощью 
https://github.com/mini-kep/parser-rosstat-kep/blob/dev/src/python/inputs/checkpoints.py

c другой сторны я сейчас пишу  https://github.com/mini-kep/parser-rosstat-kep/blob/dev/src/python-minimal/data/checkpoints.yaml
это первая и последняя точка серии 
